buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:2.2.1'
    }
}

apply plugin: Class.forName('org.sonarqube.gradle.SonarQubePlugin')
apply plugin: SonarqubeMultiProjectAdapterPlugin

sonarqube {
    properties {
        property 'sonar.java.source', sourceCompatibility
        property 'sonar.cpd.cross_project', true
        property 'sonar.rootModuleName', 'main'
    }
}


import java.lang.reflect.Field

class SonarqubeMultiProjectAdapterPlugin implements Plugin<Project> {
    private static final String TASK_NAME = 'sonarqube'
    private static final String TASK_CLASSNAME = 'org.sonarqube.gradle.SonarQubeTask'
    private static final Field TASK_PROPERTIES_FIELD = Class.forName(TASK_CLASSNAME).getDeclaredField('sonarProperties')
    private static final String PROPERTY_PREFIX = 'sonar.'
    private static final String PROPERTY_MODULES = PROPERTY_PREFIX + 'modules'
    private static final String PROPERTY_PROJECT_NAME = PROPERTY_PREFIX + 'projectName'
    private static final String PROPERTY_PROJECT_KEY = PROPERTY_PREFIX + 'projectKey'
    private static final String PROPERTY_MODULE_KEY = PROPERTY_PREFIX + 'moduleKey'
    private static final String PROPERTY_BASE_DIR = PROPERTY_PREFIX + 'projectBaseDir'
    private static final String PROPERTY_ROOTMODULE_NAME = PROPERTY_PREFIX + 'rootModuleName'
    private static final List<String> PROPERTIES_SOURCES = ['sources', 'tests']
    private static final List<String> PROPERTIES_TO_MOVE = PROPERTIES_SOURCES + [
            'sourceEncoding',
            'libraries', 'java.libraries', 'java.test.libraries',
            'binaries', 'java.binaries', 'java.test.binaries',
            'java.source', 'java.target',
            'junit.reportsPath', 'surefire.reportsPath', 'jacoco.reportPath',
            'test.exclusions'
    ]

    @Override
    void apply(Project project) {
        Task task = project.tasks.findByName(TASK_NAME)
        if (task != null) {
            task.doFirst {
                TASK_PROPERTIES_FIELD.setAccessible(true)
                TASK_PROPERTIES_FIELD.set(it, adaptProperties(it.properties))
                TASK_PROPERTIES_FIELD.setAccessible(false)
            }
        }
    }

    private static Map<String, Object> adaptProperties(Map<String, Object> properties) {
        if (hasModules(properties) && hasProjectSources(properties)) {
            String rootModule = addRootModule(properties)
            PROPERTIES_TO_MOVE.each { movePropertyToModule(properties, prefixedProperty(it), rootModule) }
        }
        return properties
    }

    private static boolean hasModules(Map<String, Object> properties) {
        return hasProperty(properties, PROPERTY_MODULES)
    }

    private static boolean hasProjectSources(Map<String, Object> properties) {
        return PROPERTIES_SOURCES.inject(false, { result, property -> result | hasProperty(properties, property) })
    }

    private static String addRootModule(Map<String, Object> properties) {
        String rootModuleName = properties.containsKey(PROPERTY_ROOTMODULE_NAME) ? properties.remove(PROPERTY_ROOTMODULE_NAME) : properties.get(PROPERTY_PROJECT_NAME)
        String rootModuleKey = rootModuleName.startsWith(":") ? rootModuleName : ":" + rootModuleName
        properties.put(PROPERTY_MODULES, rootModuleKey + "," + properties.get(PROPERTY_MODULES))
        properties.put(rootModuleKey + "." + PROPERTY_PROJECT_NAME, rootModuleName)
        properties.put(rootModuleKey + "." + PROPERTY_MODULE_KEY, properties.get(PROPERTY_PROJECT_KEY) + rootModuleKey)
        properties.put(rootModuleKey + "." + PROPERTY_BASE_DIR, properties.get(PROPERTY_BASE_DIR))
        return rootModuleKey
    }

    private static boolean hasProperty(Map<String, Object> properties, String name) {
        return properties.containsKey(prefixedProperty(name)) && properties.get(prefixedProperty(name)) != ""
    }

    private static String prefixedProperty(String name, String module = "") {
        String property =  name.startsWith(PROPERTY_PREFIX) ? name : PROPERTY_PREFIX + name
        return (module != "") ? module + "." + property : property
    }

    private static movePropertyToModule(Map<String, Object> properties, String property, String module) {
        if (properties.containsKey(property)) {
            properties.put(prefixedProperty(property, module), properties.remove(property))
        }
    }
}

